from classes.knapsacksharing import KnapsackSharing
from collections import Counter
import random


class GeneticAlgorithm:
    def __init__(self, seed):

        # Initializing seed
        self.seed = seed
        random.seed(self.seed)

        # Instantiating problem
        self.problemInstance = KnapsackSharing()

        # About population
        self.population = None
        self.currentGeneration = 0
        self.lastBestFitness = 0
        self.sameBestFitness = 0

        # Constants
        # About population
        self.SIZE_POPULATION = 100
        self.MAX_GENERATION = 10000
        self.MAX_SAME_FITNESS_GENERATIONS = 300  # Number of generations with same fitness

        # Percent of population generated by crossover
        self.PERCENT_CROSSOVER_CHROMOSOMES = 0.50
        self.NUM_CROSSOVER_CHROMOSOMES = int(self.PERCENT_CROSSOVER_CHROMOSOMES * self.SIZE_POPULATION)

        # Percent of population generated by new chromosomes
        self.PERCENT_RANDOM_CHROMOSOMES = 0.25
        self.NUM_RANDOM_CHROMOSOMES = int(self.PERCENT_RANDOM_CHROMOSOMES * self.SIZE_POPULATION)

        # Percent of population generated by best previous population chromosomes
        self.PERCENT_CLONED_CHROMOSOMES = 0.25
        self.NUM_CLONED_CHROMOSOMES = int(self.PERCENT_CLONED_CHROMOSOMES * self.SIZE_POPULATION)

        # Percent of items mutated in the worst benefit group of one chromosome
        self.PERCENT_NUM_ITEMS_CHANGED_MUTATION = 0.20
        self.NUM_ITEMS_CHANGED_MUTATION = 0  # Attributed in calculating()

        # Roulette selection method use this scale to stretch fitnesses chromosomes
        self.FITNESS_SCALE = 2.5

        # Not used anymore
        self.NUM_CHROMOSOMES_TOURNAMENT_SELECTION = 20

    # Generates one chromosome
    def generateChromosome(self):

        # Initializing chromosome struct
        chromosome = [[] for _ in range(self.problemInstance.numGroups)]
        groupIndex = 0

        for numItems in self.problemInstance.numItemsByGroups:  # Passing by each group
            for j in range(int(numItems)):  # Passing by each item of group
                p = (random.randint(0, 100))  # Generates a random probability of the item be in the bag
                if random.randint(0, 100) < p:
                    chromosome[groupIndex].append(1)  # Is the item in the bag? Randomly decides
                else:
                    chromosome[groupIndex].append(0)
            groupIndex += 1

        return chromosome

    # Generates the first population randomly
    def generateFirstPopulation(self):

        # POPULATION DATA STRUCT: List (chromosomes) of lists (groups) of lists (items) of numbers 0|1
        self.population = [[] for _ in range(self.SIZE_POPULATION)]

        # Populating randomly
        for chromosome in range(self.SIZE_POPULATION):  # Creating SIZE_POPULATION chromosomes
            self.population[chromosome] = self.generateChromosome()

    # Returns chromosome fitness (scaled or not)
    def chromosomeFitness(self, chromosome, isFitnessScaled):

        groupIndex = 0
        volume = 0
        groupsBenefits = [0 for _ in range(self.problemInstance.numGroups)]

        # Sums volumes and benefits of chromosome
        for numItems in self.problemInstance.numItemsByGroups:  # Passing by each group
            for j in range(int(numItems)):  # Passing by each item of group
                if chromosome[groupIndex][j] == 1:  # If the item is in the bag
                    volume += self.problemInstance.items[groupIndex][j][0]
                    groupsBenefits[groupIndex] += self.problemInstance.items[groupIndex][j][1]
            groupIndex += 1

        # If the volume of items in the chromosome > bag capacity
        # Remove items from the groups with the max benefits until volume <= bag capacity
        # Why correct infeasible solutions here? Because this way we avoid another loop n^2
        if volume > self.problemInstance.capacity:
            fitInTheBag = 0
            while fitInTheBag == 0:
                maxBenefitGroupIndex = groupsBenefits.index(
                    max(groupsBenefits))  # Index of the group with the max benefit
                randomItemIndex = random.randint(0,  # Index of a random item
                                                 int(self.problemInstance.numItemsByGroups[maxBenefitGroupIndex]) - 1)
                if chromosome[maxBenefitGroupIndex][randomItemIndex] == 1:  # If the item is in the bag, remove it
                    chromosome[maxBenefitGroupIndex][randomItemIndex] = 0
                    volume -= self.problemInstance.items[maxBenefitGroupIndex][randomItemIndex][0]
                    groupsBenefits[maxBenefitGroupIndex] -= \
                        self.problemInstance.items[maxBenefitGroupIndex][randomItemIndex][1]
                    if volume <= self.problemInstance.capacity:
                        fitInTheBag = 1

        # Returns scaled fitness of the group with the min benefit
        # Why returns it scaled? Because it stretches the difference between two fitness that are too closer.
        # And we wanna give higher chance to the chromosome with best fitness
        if isFitnessScaled:
            fitn = min(groupsBenefits)  # Returns the benefit of the group with the min benefit
            return int(fitn ** self.FITNESS_SCALE)
        else:  # Returns group with min benefit
            return min(groupsBenefits)

    # Crossover two chromosomes to generate one
    def crossover(self, chromosome1, chromosome2):

        # Which parent has higher fitness?
        if self.chromosomeFitness(chromosome1, 1) > self.chromosomeFitness(chromosome2, 1):
            higherFitnessChromosome = chromosome1
            lowerFitnessChromosome = chromosome2
        else:
            higherFitnessChromosome = chromosome2
            lowerFitnessChromosome = chromosome1

        chromosomeSon = [[] for _ in range(self.problemInstance.numGroups)]

        groupIndex = 0

        # WHICH TYPE OF CROSSOVER
        CROSSOVER_TYPE = 2

        # MUTATION ACTIVE?
        MUTATION = 1

        # ------------------------------------------------------------------------
        # CROSSOVER TYPE 1: son is a copy of one of the parents
        if CROSSOVER_TYPE == 1:
            probPaiMae = random.randint(1, 100)
            if probPaiMae <= 50:
                for numGroup in range(self.problemInstance.numGroups):
                    chromosomeSon[numGroup] = higherFitnessChromosome[numGroup].copy()
            else:
                for numGroup in range(self.problemInstance.numGroups):
                    chromosomeSon[numGroup] = lowerFitnessChromosome[numGroup].copy()

        # ------------------------------------------------------------------------
        # CROSSOVER TIPO 2: chooses groups of one of the parents,
        # giving higher chances to the parent with better fitness
        elif CROSSOVER_TYPE == 2:
            fitnessHigherFitnessChromosome = self.chromosomeFitness(higherFitnessChromosome, 1)
            fitnessLowerFitnessChromosome = self.chromosomeFitness(lowerFitnessChromosome, 1)
            sum = fitnessHigherFitnessChromosome + fitnessLowerFitnessChromosome

            prob = random.randint(1, sum)

            for numGroup in range(self.problemInstance.numGroups):
                if prob <= fitnessLowerFitnessChromosome:
                    chromosomeSon[numGroup] = lowerFitnessChromosome[numGroup].copy()
                else:
                    chromosomeSon[numGroup] = higherFitnessChromosome[numGroup].copy()


        # ------------------------------------------------------------------------
        # CROSSOVER TIPO 3: chooses items from each parent
        # with 75% of chance to pick from the parent with better benefit and 25% from the other
        elif CROSSOVER_TYPE == 3:
            for numItems in self.problemInstance.numItemsByGroups:
                for item in range(int(numItems)):  # Passing by each item of group
                    prob = random.randint(1, 100)
                    if prob <= 75:
                        chromosomeSon[groupIndex].append(higherFitnessChromosome[groupIndex][item])
                    else:
                        chromosomeSon[groupIndex].append(lowerFitnessChromosome[groupIndex][item])
                groupIndex += 1

        # ------------------------------------------------------------------------
        # MUTATION: Mutate NUM_ITEMS_CHANGED_MUTATION from the group with worst benefit

        groupsBenefits = [0 for _ in range(self.problemInstance.numGroups)]

        groupIndex = 0

        # Sum volumes and benefits of chromosome
        for numItems in self.problemInstance.numItemsByGroups:  # Passing by each group
            for j in range(int(numItems)):  # Passing by each item of group
                if chromosomeSon[groupIndex][j] == 1:  # If the item is in the bag
                    groupsBenefits[groupIndex] += self.problemInstance.items[groupIndex][j][1]
            groupIndex += 1

        sortedGroupsFitnesses = sorted(enumerate(groupsBenefits), key=lambda x: x[1])

        if MUTATION == 1:
            prob1 = random.randint(1, 100)
            if prob1 <= 50:
                for k in range(self.NUM_ITEMS_CHANGED_MUTATION):
                    n = int(self.problemInstance.numItemsByGroups[sortedGroupsFitnesses[0][0]])
                    indexToMutate = random.randint(0, n - 1)
                    if chromosomeSon[sortedGroupsFitnesses[0][0]][indexToMutate] == 1:
                        chromosomeSon[sortedGroupsFitnesses[0][0]][indexToMutate] = 0
                    else:
                        chromosomeSon[sortedGroupsFitnesses[0][0]][indexToMutate] = 1

        return chromosomeSon

    # Tournament Selection Method -> NOT USED ANYMORE (roulette used)
    def tournamentSelection(self):

        competitorsFitness = [0 for _ in range(self.NUM_CHROMOSOMES_TOURNAMENT_SELECTION)]
        competitorsIndex = [0 for _ in range(self.NUM_CHROMOSOMES_TOURNAMENT_SELECTION)]

        for j in range(self.NUM_CHROMOSOMES_TOURNAMENT_SELECTION):
            # cu random.seed(self.problemInstance.seed)
            randomIndex = random.randint(0, len(self.population) - 1)
            competitorsIndex[j] = randomIndex
            competitorsFitness[j] = self.chromosomeFitness(self.population[randomIndex], 1)

        winnerChromosome = self.population[competitorsIndex[competitorsFitness.index(max(competitorsFitness))]]

        return winnerChromosome

    # Group Selection Method -> NOT USED ANYMORE (roulette used)
    def groupSelection(self):
        # Sorts the population by fitness. 75% of chance to pick a chromosome from the first half of the population
        populationFitness = []
        chromosomeIndexes = []

        # Calculates the fitness for all population
        for i in range(len(self.population)):
            populationFitness.append(self.chromosomeFitness(self.population[i], 1))

        # Sorts population by fitness
        for i in range(len(self.population)):
            indexBestFitness = populationFitness.index(max(populationFitness))
            chromosomeIndexes.append(indexBestFitness)
            populationFitness[indexBestFitness] = 0  # The best fitness is not the best fitness anymore

        # cu random.seed(self.problemInstance.seed)
        prob = random.randint(1, 100)

        # 75% of chance to be one chromosome from the first half of the population
        if prob <= 60:
            # cu random.seed(self.problemInstance.seed)
            indexFromFirstPart = random.randint(0, self.SIZE_POPULATION // 2)
            chromosomeWinnerIndex = chromosomeIndexes[indexFromFirstPart]
            return self.population[chromosomeIndexes[chromosomeWinnerIndex]]
        else:
            # cu random.seed(self.problemInstance.seed)
            indexFromSecondPart = random.randint(self.SIZE_POPULATION // 2 + 1, self.SIZE_POPULATION - 1)
            chromosomeWinnerIndex = chromosomeIndexes[indexFromSecondPart]
            return self.population[chromosomeIndexes[chromosomeWinnerIndex]]

    # Roulette Selection Method -> USED
    def rouletteSelection(self):

        # We used scaled fitness to stretch the difference between two chromosomes fitness

        sumFitness = 0

        for i in range(self.SIZE_POPULATION):
            sumFitness += self.chromosomeFitness(self.population[i], 1)

        randomProb = random.randint(0, sumFitness)
        t = 0

        for i in range(self.SIZE_POPULATION):
            t += self.chromosomeFitness(self.population[i], 1)
            if t >= randomProb:
                return self.population[i]

    # Generates new population
    def generatingNewPopulation(self):

        # POPULATION DATA STRUCT: List (chromosomes) of lists (groups) of lists (items) of numbers 0|1
        newPopulation = []

        # NUM_CROSSOVER_CHROMOSOMES come from crossover
        for i in range(self.NUM_CROSSOVER_CHROMOSOMES):
            parent1 = self.rouletteSelection()
            parent2 = self.rouletteSelection()
            newPopulation.append(self.crossover(parent1, parent2))

        # NUM_CLONED CHROMOSOMES come from the best chromosomes of previous population
        populationFitness = []
        for i in range(len(self.population)):
            populationFitness.append(self.chromosomeFitness(self.population[i], 1))

        populationFitnessSortedWithIndex = sorted(enumerate(populationFitness), key=lambda x: -x[1])
        elite = [self.population[populationFitnessSortedWithIndex[i][0]] for i in range(self.NUM_CLONED_CHROMOSOMES)]
        newPopulation.extend(elite)

        # And NUM_RANDOM_CHROMOSOMES come from new chromosomes
        randoms = []
        for i in range(self.NUM_RANDOM_CHROMOSOMES):
            randoms.append(self.generateChromosome())
        newPopulation.extend(randoms)

        self.currentGeneration += 1
        self.population = newPopulation

    # Checks if the solution is feasible -> NOT USED ANYMORE (does not accept infeasible solutions)
    def feasibleSolution(self, chromosome):
        # NOT USED ANYMORE
        groupIndex = 0
        volume = 0

        # Sum volumes and benefits of chromosome
        for numItems in self.problemInstance.numItemsByGroups:  # Passing by each group
            for j in range(int(numItems)):  # Passing by each item of group
                if chromosome[groupIndex][j] == 1:  # If the item is in the bag
                    volume += self.problemInstance.items[groupIndex][j][0]
            groupIndex += 1

        # If the volume of items in the chromosome > bag capacity
        # Fitness is decreased proportionally
        if volume > self.problemInstance.capacity:
            return 0
        else:
            return 1

    # Executes GA
    def calculating(self, file):

        self.problemInstance.readingfile(file)
        self.problemInstance.generatingGlpkData()
        self.generateFirstPopulation()

        self.NUM_ITEMS_CHANGED_MUTATION = int(
            self.PERCENT_NUM_ITEMS_CHANGED_MUTATION * (min(self.problemInstance.numItemsByGroups)))

        while self.sameBestFitness <= self.MAX_SAME_FITNESS_GENERATIONS:

            print('***********************************')
            print("      GENERATION NUMBER ", self.currentGeneration)
            populationFitness = []

            # Calculate fitness for all the chromosomes
            for i in range(len(self.population)):
                populationFitness.append(self.chromosomeFitness(self.population[i], 0))
            #print(populationFitness)
            print("      FITNESS: ", max(populationFitness))
            print('***********************************')

            if self.lastBestFitness == max(populationFitness):
                self.sameBestFitness += 1
            else:
                self.lastBestFitness = max(populationFitness)
                self.sameBestFitness = 0

            self.generatingNewPopulation()
